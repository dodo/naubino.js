
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define('Layer',[],function() {
    var Layer;
    return Layer = (function() {

      function Layer(canvas) {
        var _this = this;
        this.canvas = canvas;
        this.color_to_rgba = __bind(this.color_to_rgba, this);
        this.move_pointer = __bind(this.move_pointer, this);
        this.unfocus = __bind(this.unfocus, this);
        this.click = __bind(this.click, this);
        this.do_draw = __bind(this.do_draw, this);
        this.do_step = __bind(this.do_step, this);
        this.stop_stepper = __bind(this.stop_stepper, this);
        this.start_stepper = __bind(this.start_stepper, this);
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.center = new b2Vec2(this.width / 2, this.height / 2);
        this.ctx = this.canvas.getContext('2d');
        this.pointer = this.center.Copy();
        this.objects = {};
        this.objects_count = 0;
        this.physics_fps = Naubino.settings.physics.fps;
        this.fps = Naubino.settings.graphics.fps;
        this.dt = Naubino.settings.physics.fps / 1000 * Naubino.settings.physics.calming_const;
        this.time = Date.now();
        this.cut = 0;
        this.show();
        this.animation = {
          parent: this,
          start_timer: function() {
            return _this.draw_loop = setInterval(_this.do_draw, 1000 / _this.fps);
          },
          stop_timer: function() {
            return clearInterval(_this.draw_loop);
          }
        };
        StateMachine.create({
          target: this.animation,
          initial: 'stopped',
          events: Naubino.settings.layer_events,
          callbacks: {
            error: function(e, from, to, args, code, msg) {
              return console.error("" + this.name + "." + e + ": " + from + " -> " + to + "\n" + code + "::" + msg);
            },
            onbeforeplay: function(e, f, t) {
              return this.start_timer();
            },
            onbeforepause: function(e, f, t) {
              return this.stop_timer();
            },
            onbeforestop: function(e, f, t) {
              this.stop_timer();
              return this.parent.clear();
            },
            onchangestate: function(e, f, t) {}
          }
        });
      }

      /* overwrite these
      */

      Layer.prototype.draw = function() {};

      Layer.prototype.step = function(dt) {};

      Layer.prototype.get_dt = function() {
        var old_time;
        old_time = this.time;
        this.time = Date.now();
        return this.time - old_time;
      };

      Layer.prototype.start_stepper = function() {
        return this.loop = setInterval(this.do_step, 1000 / this.physics_fps);
      };

      Layer.prototype.stop_stepper = function() {
        return clearInterval(this.loop);
      };

      Layer.prototype.do_step = function() {
        return this.step(this.dt);
      };

      Layer.prototype.do_draw = function() {
        if (this.drawing) return this.draw();
      };

      /* managing objects
      */

      Layer.prototype.add_object = function(obj) {
        obj.center = this.center;
        this.objects_count++;
        obj.number = this.objects_count;
        this.objects[this.objects_count] = obj;
        return this.objects_count;
      };

      Layer.prototype.get_object = function(id) {
        return this.objects[id];
      };

      Layer.prototype.remove_obj = function(id) {
        return delete this.objects[id];
      };

      Layer.prototype.clear_objects = function() {
        return this.objects = {};
      };

      Layer.prototype.for_each = function(callback) {
        var k, v, _ref, _results;
        _ref = this.objects;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(callback(v));
        }
        return _results;
      };

      Layer.prototype.fade_in = function(callback) {
        var fade,
          _this = this;
        if (callback == null) callback = null;
        console.log("fade in", this.fadeloop);
        this.canvas.style.opacity = 0.01;
        if (this.backup_ctx != null) this.restore();
        fade = function() {
          if ((_this.canvas.style.opacity *= 1.2) >= 1) {
            clearInterval(_this.fadeloop);
            console.log("done");
            _this.show();
            if (callback != null) return callback.call();
          }
        };
        clearInterval(this.fadeloop);
        return console.log(this.fadeloop = setInterval(fade, 40));
      };

      Layer.prototype.fade_out = function(callback) {
        var fade,
          _this = this;
        if (callback == null) callback = null;
        console.log("fade out", this.fadeloop);
        this.cache();
        fade = function() {
          if ((_this.canvas.style.opacity *= 0.8) <= 0.05) {
            clearInterval(_this.fadeloop);
            _this.hide();
            if (callback != null) return callback.call();
          }
        };
        clearInterval(this.fadeloop);
        return console.log(this.fadeloop = setInterval(fade, 40));
      };

      Layer.prototype.show = function() {
        return this.canvas.style.opacity = 1;
      };

      Layer.prototype.hide = function() {
        return this.canvas.style.opacity = 0;
      };

      Layer.prototype.clear = function() {
        return this.canvas.width = this.canvas.width;
      };

      Layer.prototype.cache = function() {
        return this.backup_ctx = this.ctx;
      };

      Layer.prototype.restore = function() {
        return this.ctx = this.backup_ctx;
      };

      Layer.prototype.click = function(x, y) {
        var naub, _ref;
        this.mousedown = true;
        _ref = [x, y], this.pointer.x = _ref[0], this.pointer.y = _ref[1];
        naub = this.get_obj(x, y);
        if (naub) {
          naub.focus();
          return this.focused_naub = naub;
        }
      };

      Layer.prototype.unfocus = function() {
        this.mousedown = false;
        if (this.focused_naub) this.focused_naub.unfocus();
        return this.focused_naub = null;
      };

      Layer.prototype.move_pointer = function(x, y) {
        var _ref;
        if (this.mousedown) {
          return _ref = [x, y], this.pointer.x = _ref[0], this.pointer.y = _ref[1], _ref;
        }
      };

      Layer.prototype.get_obj = function(x, y) {
        var id, obj, _ref;
        _ref = this.objects;
        for (id in _ref) {
          obj = _ref[id];
          if (obj.isHit(x, y) && obj.isClickable) return obj;
        }
      };

      /* utils
      */

      Layer.prototype.color_to_rgba = function(color, shift) {
        var a, b, g, r;
        if (shift == null) shift = 0;
        r = Math.round(color[0] + shift);
        g = Math.round(color[1] + shift);
        b = Math.round(color[2] + shift);
        a = color[3];
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      };

      return Layer;

    })();
  });

}).call(this);

(function() {
  var __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('Background',["Layer"], function(Layer) {
    var Background;
    return Background = (function(_super) {

      __extends(Background, _super);

      function Background(canvas) {
        Background.__super__.constructor.call(this, canvas);
        this.name = "background";
        this.animation.name = "background.animation";
        this.drawing = true;
        this.default_thickness = this.basket_thickness = 4;
        this.ttl = 12;
        this.color = [0, 0, 0, 0.5];
        this.pulsating = false;
        this.seed = 0;
      }

      Background.prototype.draw = function() {
        return this.draw_basket();
      };

      Background.prototype.step = function(dt) {
        if (this.pulsating) return this.pulse();
      };

      Background.prototype.draw_basket = function() {
        var centerX, centerY, height, width;
        width = this.canvas.width;
        height = this.canvas.height;
        centerX = width / 2;
        centerY = height / 2;
        this.basket_size = Naubino.game.basket_size || 10;
        this.ctx.clearRect(0, 0, width, height);
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, this.basket_size + this.basket_thickness / 2, 0, Math.PI * 2, false);
        this.ctx.lineWidth = this.basket_thickness;
        this.ctx.strokeStyle = this.color_to_rgba(this.color);
        this.ctx.stroke();
        this.ctx.closePath();
        return this.ctx.restore();
      };

      Background.prototype.start_pulse = function() {
        if (this.animation.current !== "playing") this.animation.play();
        return this.pulsating = true;
      };

      Background.prototype.stop_pulse = function() {
        return this.pulse_ends = true;
      };

      Background.prototype.pulse = function() {
        var rot;
        if (this.pulse_ends && Math.abs(this.default_thickness - this.basket_thickness) < 1) {
          this.pulsating = false;
          this.pulse_ends = false;
          this.basket_thickness = this.default_thickness;
          this.color[0] = 0;
          this.color[3] = 0.5;
          this.animation.pause();
        }
        this.basket_thickness = Math.abs(Math.sin(this.seed / this.ttl)) * 2 * this.default_thickness + this.default_thickness;
        rot = Math.sin(this.seed / this.ttl);
        this.color[0] = Math.abs(rot) * 200;
        this.color[3] = Math.abs(rot) * 0.5 + 0.5;
        return this.seed++;
      };

      Background.prototype.drawTextAlongArc = function(str, rot) {
        var angle, char, _i, _len;
        if (rot == null) rot = 0;
        angle = str.length * 0.1;
        this.ctx.save();
        this.ctx.translate(this.center.x, this.center.y);
        this.ctx.rotate(-1 * angle / 2);
        this.ctx.rotate(-1 * (angle / str.length) / 2 + rot);
        for (_i = 0, _len = str.length; _i < _len; _i++) {
          char = str[_i];
          this.ctx.rotate(angle / str.length);
          this.ctx.save();
          this.ctx.translate(0, -1 * this.basket_size + 15);
          this.ctx.fillStyle = this.color_to_rgba(this.color);
          this.ctx.textAlign = 'center';
          this.ctx.font = "" + 20 + "px Helvetica";
          this.ctx.fillText(char, 0, 0);
          this.ctx.restore();
        }
        return this.ctx.restore();
      };

      Background.prototype.draw_marker = function(x, y, color) {
        if (color == null) color = 'black';
        this.ctx.beginPath();
        this.ctx.arc(x, y, 4, 0, 2 * Math.PI, false);
        this.ctx.arc(x, y, 1, 0, 2 * Math.PI, false);
        this.ctx.lineWidth = 1;
        this.ctx.strokeStyle = color;
        this.ctx.stroke();
        return this.ctx.closePath();
      };

      Background.prototype.draw_line = function(x0, y0, x1, y1, color) {
        if (x1 == null) x1 = this.center.x;
        if (y1 == null) y1 = this.center.y;
        if (color == null) color = 'black';
        this.ctx.beginPath();
        this.ctx.moveTo(x0, y0);
        this.ctx.lineTo(x1, y1);
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = color;
        this.ctx.stroke();
        return this.ctx.closePath();
      };

      return Background;

    })(Layer);
  });

}).call(this);

(function() {

  define('PhysicsModel',[],function() {
    var PhysicsModel;
    return PhysicsModel = (function() {

      function PhysicsModel(naub) {
        this.naub = naub;
        this.pos = new b2Vec2(0, 0);
        this.vel = new b2Vec2(0, 0);
        this.force = new b2Vec2(0, 0);
        this.attracted_to = new b2Vec2(0, 0);
        this.mass = this.default_mass = Naubino.settings.naub.mass;
        this.friction = this.default_friction = Naubino.settings.physics.friction;
        this.spring_force = Naubino.settings.physics.spring_force;
        this.margin = Naubino.settings.physics.margin;
        this.join_length = Naubino.settings.physics.join_length;
      }

      PhysicsModel.prototype.step = function(dt) {
        var v;
        v = this.force.Copy();
        v.Multiply(dt);
        this.pos.Add(v);
        this.acceleration = new b2Vec2(0, 0);
        return this.apply_friction();
      };

      PhysicsModel.prototype.gravitate = function(dt, to) {
        var diff;
        if (to == null) to = this.attracted_to;
        if (!(this.naub.focused || !this.naub.layer.gravity)) {
          diff = to.Copy();
          diff.Subtract(this.pos);
          diff.Multiply(dt);
          diff.Multiply(this.mass);
          return this.accelerate(diff);
        }
      };

      PhysicsModel.prototype.accelerate = function(diff) {
        return this.force.Add(diff);
      };

      PhysicsModel.prototype.apply_friction = function() {
        return this.force.Multiply(1 / this.friction);
      };

      PhysicsModel.prototype.follow = function(v) {
        var pl;
        if (v == null) v = this.attracted_to;
        pl = v.Copy();
        pl.Subtract(this.pos);
        pl = pl.Length();
        v.Subtract(this.pos);
        v.Normalize();
        v.Multiply(30 * pl);
        return this.force.Add(v);
      };

      PhysicsModel.prototype.collide = function(other) {
        var diff, keep_distance, l, oforce, opos, ovel, v, _ref;
        if (this.naub.number !== other.number) {
          _ref = other.physics, opos = _ref.pos, ovel = _ref.vel, oforce = _ref.force;
          keep_distance = (this.naub.size + other.size) * this.margin;
          diff = opos.Copy();
          diff.Subtract(this.pos);
          l = diff.Length();
          if (this.naub.number < other.number && l < keep_distance) {
            v = diff.Copy();
            v.Normalize();
            v.Multiply(keep_distance - l);
            v.Multiply(0.6);
            this.pos.Subtract(v);
            opos.Add(v);
            this.force.Subtract(v);
            return oforce.Add(v);
          }
        }
      };

      PhysicsModel.prototype.join_springs = function(other) {
        var diff, keep_distance, l, oforce, opos, ovel, v, _ref;
        _ref = other.physics, opos = _ref.pos, ovel = _ref.vel, oforce = _ref.force;
        keep_distance = (this.naub.size + other.size) * this.join_length;
        diff = opos.Copy();
        diff.Subtract(this.pos);
        l = diff.Length();
        v = diff.Copy();
        v.Normalize();
        v.Multiply(-1 / 1000 * this.spring_force * l * l * l % 1000);
        this.force.Subtract(v);
        oforce.Add(v);
        if (l < keep_distance) {
          v = diff.Copy();
          v.Normalize();
          v.Multiply(keep_distance - l);
          v.Multiply(0.6);
          this.vel.Subtract(v);
          ovel.Add(v);
          this.force.Subtract(v);
          return oforce.Add(v);
        }
      };

      return PhysicsModel;

    })();
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define('Naub',["PhysicsModel"], function(PhysicsModel) {
    var Naub;
    return Naub = (function() {

      function Naub(layer, color_id, size) {
        this.layer = layer;
        this.color_id = color_id != null ? color_id : null;
        this.size = size != null ? size : Naubino.settings.naub.size;
        this.color_to_rgba = __bind(this.color_to_rgba, this);
        this.remove = __bind(this.remove, this);
        this.draw_joins = __bind(this.draw_joins, this);
        this.physics = new PhysicsModel(this);
        this.physics.attracted_to = this.layer.center.Copy();
        this.ctx = this.layer.ctx;
        this.frame = this.size * 1.5;
        if (this.color_id == null) this.color_id = this.random_palette_color();
        this.life_rendering = false;
        this.removed = false;
        this.focused = false;
        this.disabled = false;
        this.isClickable = true;
        this.shapes = [];
        this.joins = {};
        this.drawing_join = {};
        this.join_style = {
          fill: [0, 0, 0, 1],
          width: 6
        };
        this.update();
      }

      Naub.prototype.draw = function(ctx) {
        var pos, x, y;
        pos = this.physics.pos;
        if (!(Naubino.settings.graphics.updating || this.life_rendering)) {
          ctx.save();
          x = pos.x - this.frame;
          y = pos.y - this.frame;
          this.ctx.drawImage(this.buffer, x, y);
          return this.ctx.restore();
        } else {
          return this.render(this.ctx, pos.x, pos.y);
        }
      };

      Naub.prototype.update = function() {
        var b_ctx;
        this.buffer = document.createElement('canvas');
        this.buffer.width = this.buffer.height = this.frame * 2;
        b_ctx = this.buffer.getContext('2d');
        return this.render(b_ctx, this.frame, this.frame);
      };

      Naub.prototype.resize = function(size) {
        var attracted_to, force, pos, vel, _ref;
        if (size == null) size = null;
        this.size = size != null ? size : Naubino.settings.naub.size;
        this.frame = this.size * 1.5;
        _ref = this.physics, pos = _ref.pos, vel = _ref.vel, force = _ref.force, attracted_to = _ref.attracted_to;
        this.physics = new PhysicsModel(this);
        Util.extend(this.physics, {
          pos: pos,
          vel: vel,
          force: force,
          attracted_to: attracted_to
        });
        return this.update();
      };

      Naub.prototype.render = function(ctx, x, y) {
        var shape, _i, _len, _ref, _results;
        _ref = this.shapes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shape = _ref[_i];
          _results.push(shape.render(ctx, x, y));
        }
        return _results;
      };

      Naub.prototype.add_shape = function(shape) {
        shape.setup(this);
        return this.shapes.push(shape);
      };

      Naub.prototype.update_shapes = function() {
        var shape, _i, _len, _ref, _results;
        _ref = this.shapes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shape = _ref[_i];
          _results.push(shape.setup(this));
        }
        return _results;
      };

      Naub.prototype.area = function() {
        var r;
        r = this.size * this.physics.margin;
        return Math.floor(r * r * Math.PI);
      };

      Naub.prototype.real_area = function() {
        var shape, _i, _len, _ref;
        _ref = this.shapes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shape = _ref[_i];
          if (shape.area) return shape.area();
        }
        return 0;
      };

      Naub.prototype.draw_joins = function(context) {
        var id, partner, _ref;
        _ref = this.joins;
        for (id in _ref) {
          partner = _ref[id];
          if (this.drawing_join[id]) this.draw_join(context, partner);
        }
      };

      Naub.prototype.draw_join = function(ctx, partner) {
        var diff, fiber, l, m, pos, pos2, stretch, stretched_width;
        pos = this.physics.pos;
        pos2 = partner.physics.pos;
        diff = pos2.Copy();
        diff.Subtract(pos);
        l = diff.Length();
        m = this.physics.margin * 25;
        fiber = 10;
        stretch = (m + fiber) / (l + fiber);
        stretch = Math.round(stretch * 10) / 10;
        stretched_width = this.join_style.width * stretch;
        ctx.save();
        ctx.strokeStyle = this.color_to_rgba(this.join_style.fill);
        try {
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos2.x, pos2.y);
          ctx.lineWidth = stretched_width;
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.closePath();
          return ctx.restore();
        } catch (e) {
          return this.layer.menu_pause.dispatch();
        }
      };

      Naub.prototype.step = function(dt) {
        return this.physics.step(dt);
      };

      Naub.prototype.disable = function() {
        this.disabled = true;
        return this.update();
      };

      Naub.prototype.enable = function() {
        this.disabled = false;
        return this.update();
      };

      Naub.prototype.grey_out = function() {
        return this.style.fill = [100, 100, 100, 1];
      };

      Naub.prototype.recolor = function() {
        return this.style.fill = Naubino.colors[this.color_id];
      };

      Naub.prototype.remove = function() {
        var id, naub, _ref, _results;
        this.removed = true;
        _ref = this.joins;
        _results = [];
        for (id in _ref) {
          naub = _ref[id];
          delete naub.joins[id];
          _results.push(this.layer.graph.remove_join(id));
        }
        return _results;
      };

      Naub.prototype.destroy = function() {
        var id, partner, shape, _i, _len, _ref, _ref2;
        _ref = this.joins;
        for (id in _ref) {
          partner = _ref[id];
          this.drawing_join[id] = true;
          partner.drawing_join[id] = false;
        }
        this.destroying = true;
        this.shapes[0].destroy_animation(this.remove);
        _ref2 = this.shapes.slice(1);
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          shape = _ref2[_i];
          shape.destroy_animation();
        }
        return this.layer.naub_destroyed.dispatch(this.number);
      };

      Naub.prototype.join_with = function(other) {
        var join;
        join = this.layer.graph.add_join(this, other);
        this.joins[join] = other;
        this.drawing_join[join] = true;
        other.joins[join] = this;
        other.drawing_join[join] = false;
        if (this.layer.naub_joined != null) this.layer.naub_joined.dispatch();
        return join;
      };

      Naub.prototype.replace_with = function(other) {
        var id, naub, remove_joins;
        remove_joins = (function() {
          var _ref, _results;
          _ref = this.joins;
          _results = [];
          for (id in _ref) {
            naub = _ref[id];
            other.join_with(naub);
            delete naub.joins[id];
            _results.push(this.layer.graph.remove_join(id));
          }
          return _results;
        }).call(this);
        this.layer.unfocus();
        this.remove();
        this.layer.naub_replaced.dispatch(other.number);
        return 42;
      };

      Naub.prototype.is_joined_with = function(other) {
        var id, joined, opnaub, _ref;
        joined = false;
        _ref = this.joins;
        for (id in _ref) {
          opnaub = _ref[id];
          if (opnaub === other) joined = true;
        }
        return joined;
      };

      Naub.prototype.joined_naubs = function() {
        var id, list, naub, _ref;
        list = [];
        _ref = this.joins;
        for (id in _ref) {
          naub = _ref[id];
          list.push(naub.number);
        }
        return this.joins;
      };

      Naub.prototype.partners = function() {
        var x, _i, _len, _ref, _results;
        _ref = this.joins;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          _results.push(x);
        }
        return _results;
      };

      Naub.prototype.distance_to = function(other) {
        var diff, force, l, oforce, opos, ovel, pos, vel, _ref, _ref2;
        if (other.number !== this.number) {
          _ref = this.physics, pos = _ref.pos, vel = _ref.vel, force = _ref.force;
          _ref2 = other.physics, opos = _ref2.pos, ovel = _ref2.vel, oforce = _ref2.force;
          diff = opos.Copy();
          diff.Subtract(pos);
          return l = diff.Length();
        } else {
          return NaN;
        }
      };

      Naub.prototype.onclick = function() {};

      Naub.prototype.onfocus = function() {};

      Naub.prototype.focus = function() {
        this.focused = true;
        this.update();
        this.onfocus();
        return this.layer.naub_focused.dispatch(this);
      };

      Naub.prototype.unfocus = function() {
        this.focused = false;
        this.update();
        this.onclick();
        return this.layer.naub_unfocused.dispatch(this);
      };

      Naub.prototype.isHit = function(x, y) {
        var click, s;
        s = Naubino.settings.canvas.scale;
        click = new b2Vec2(x, y);
        click.Subtract(this.physics.pos);
        return (click.Length() < this.size) && !this.removed && !this.disabled;
      };

      Naub.prototype.color_to_rgba = function(color, shift) {
        var a, b, g, r;
        if (shift == null) shift = 0;
        r = Math.round(color[0] + shift);
        g = Math.round(color[1] + shift);
        b = Math.round(color[2] + shift);
        a = color[3];
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      };

      Naub.prototype.random_palette_color = function() {
        var id, palette;
        palette = Naubino.colors;
        return id = Math.round(Math.random() * (palette.length - 1));
      };

      return Naub;

    })();
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define('Graph',[],function() {
    var Graph;
    return Graph = (function() {

      function Graph(layer) {
        this.layer = layer;
        this.cycle_test = __bind(this.cycle_test, this);
        this.join_id_sequence = 0;
        this.naubs = [];
        this.joins = {};
      }

      Graph.prototype.update_naub_list = function() {
        var i, id, join, _ref, _results;
        this.naubs = [];
        _ref = this.joins;
        _results = [];
        for (id in _ref) {
          join = _ref[id];
          _results.push((function() {
            var _ref2, _results2;
            _results2 = [];
            for (i = 0; i <= 1; i++) {
              if (_ref2 = join[i], __indexOf.call(this.naubs, _ref2) < 0) {
                _results2.push(this.naubs.push(join[i]));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          }).call(this));
        }
        return _results;
      };

      Graph.prototype.add_join = function(a, b) {
        var join;
        this.join_id_sequence++;
        join = [a.number, b.number];
        this.joins[this.join_id_sequence] = join;
        this.update_naub_list();
        return this.join_id_sequence;
      };

      Graph.prototype.remove_join = function(id) {
        delete this.joins[id];
        return this.update_naub_list();
      };

      Graph.prototype.clear = function() {
        this.join_id_sequence = 0;
        this.naubs = [];
        return this.joins = {};
      };

      Graph.prototype.join_list = function() {
        var id, join, _ref, _results;
        console.log("joinList");
        _ref = this.joins;
        _results = [];
        for (id in _ref) {
          join = _ref[id];
          _results.push(console.log(id + " " + join));
        }
        return _results;
      };

      Graph.prototype.dotty = function() {
        var dot, id, join, joins;
        dot = "graph G {\n";
        joins = (function() {
          var _ref, _results;
          _ref = this.joins;
          _results = [];
          for (id in _ref) {
            join = _ref[id];
            _results.push(join[0] + " -- " + join[1]);
          }
          return _results;
        }).call(this);
        dot += joins.join("\n") + "}";
        return console.log(dot);
      };

      Graph.prototype.partners = function(naub, pre) {
        var id, join, partners, _ref;
        if (pre == null) pre = null;
        partners = [];
        _ref = this.joins;
        for (id in _ref) {
          join = _ref[id];
          if (__indexOf.call(join, naub) >= 0) {
            if (__indexOf.call(join, pre) < 0) {
              partners.push(join[(join.indexOf(naub)) ^ 1]);
            }
          }
        }
        return partners;
      };

      Graph.prototype.cycle_test = function(first) {
        var color, cycles, dfs_cycle, dfs_num, inaub, naub, _i, _len, _ref, _ref2, _ref3;
        cycles = [];
        this.dfs_map = [];
        _ref = this.naubs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          inaub = _ref[_i];
          this.dfs_map[inaub] = {
            naub: inaub,
            dfs_num: 0,
            color: 0
          };
        }
        this.seq_num = 1;
        _ref2 = this.dfs_map;
        for (inaub in _ref2) {
          _ref3 = _ref2[inaub], naub = _ref3.naub, dfs_num = _ref3.dfs_num, color = _ref3.color;
          if (dfs_num === 0) {
            dfs_cycle = this.dfs(naub, null, first);
            cycles = cycles.filter(function(x) {
              return __indexOf.call(dfs_cycle, x) >= 0;
            });
          }
        }
      };

      Graph.prototype.dfs = function(naub, pre, first) {
        var cycles, list, partner, _i, _len, _ref;
        if (pre == null) pre = null;
        if (first == null) first = null;
        cycles = [];
        this.dfs_map[naub].dfs_num = this.seq_num;
        this.seq_num++;
        this.dfs_map[naub].color = 1;
        _ref = this.partners(naub, pre);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          partner = _ref[_i];
          if (this.dfs_map[partner].dfs_num === 0) {
            cycles = this.dfs(partner, naub, first).filter(function(x) {
              return __indexOf.call(cycles, x) >= 0;
            });
          }
          if (this.dfs_map[partner].color === 1) {
            list = this.cycle_list(naub, partner, first);
            if (list.length > 0) this.layer.cycle_found.dispatch(list);
          }
        }
        this.dfs_map[naub].color = 2;
        return cycles;
      };

      Graph.prototype.cycle_list = function(v, w, first) {
        var cycle, cycle_naubs, i, x,
          _this = this;
        if (first == null) first = null;
        cycle = this.dfs_map.filter(function(_arg) {
          var color, dfs_num;
          dfs_num = _arg.dfs_num, color = _arg.color;
          return dfs_num >= _this.dfs_map[w].dfs_num && color === 1;
        });
        cycle.sort(function(a, b) {
          return a.dfs_num - b.dfs_num;
        });
        cycle_naubs = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = cycle.length; _i < _len; _i++) {
            x = cycle[_i];
            _results.push(x.naub);
          }
          return _results;
        })();
        if ((first != null) && __indexOf.call(cycle_naubs, first) >= 0) {
          cycle_naubs = cycle_naubs;
          i = cycle_naubs.indexOf(first);
          cycle_naubs = cycle_naubs.slice(i, cycle_naubs.length).concat(cycle_naubs.slice(0, i));
        }
        return cycle_naubs;
      };

      return Graph;

    })();
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('Shapes',[],function() {
    var Ball, Clock, Frame, FrameCircle, MainButton, NumberShape, PauseButton, PlayButton, Shape, Shapes, Square, StringShape;
    return Shapes = {
      Shape: Shape = (function() {

        function Shape() {
          this.color_to_rgba = __bind(this.color_to_rgba, this);          this.style = {
            fill: [0, 0, 0, 1]
          };
        }

        Shape.prototype.setup = function(naub) {
          this.naub = naub;
          this.pos = this.naub.pos;
          this.ctx = this.naub.ctx;
          return this.set_color_from_id(this.naub.color_id);
        };

        Shape.prototype.color_to_rgba = function(color, shift) {
          var a, b, g, r;
          if (color == null) color = this.style.fill;
          if (shift == null) shift = 0;
          r = Math.round(color[0] + shift);
          g = Math.round(color[1] + shift);
          b = Math.round(color[2] + shift);
          a = color[3];
          return "rgba(" + r + "," + g + "," + b + "," + a + ")";
        };

        Shape.prototype.draw_shadow = function(ctx) {
          if (Naubino.settings.graphics.draw_shadows) {
            ctx.shadowColor = "#333";
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 1;
            return ctx.shadowOffsetY = 1;
          }
        };

        Shape.prototype.set_opacity = function(value) {
          return this.style.fill[3] = value;
        };

        Shape.prototype.set_color_from_id = function(id) {
          var palette, pick;
          palette = Naubino.colors;
          pick = palette[id];
          this.style.fill = [pick[0], pick[1], pick[2], 1];
          return id;
        };

        Shape.prototype.random_color = function() {
          var b, g, r;
          r = Math.random();
          g = Math.random();
          b = Math.random();
          this.style.fill = [r, g, b, 1];
          return -1;
        };

        Shape.prototype.destroy_animation = function(callback) {
          var shrink,
            _this = this;
          if (callback == null) callback = null;
          this.naub.life_rendering = true;
          shrink = function() {
            _this.naub.size *= 0.8;
            _this.naub.join_style.width *= 0.6;
            _this.naub.join_style.fill[3] *= 0.6;
            _this.style.fill[3] *= 0.6;
            if ((callback != null) && _this.naub.size <= 0.1) {
              clearInterval(_this.loop);
              return callback.call();
            }
          };
          return this.loop = setInterval(shrink, 50);
        };

        return Shape;

      })(),
      Square: Square = (function(_super) {

        __extends(Square, _super);

        function Square() {
          Square.__super__.constructor.call(this);
          this.rot = 0;
        }

        Square.prototype.area = function() {
          return this.width / 2 * this.width / 2;
        };

        Square.prototype.render = function(ctx, x, y) {
          ctx.save();
          this.width = this.naub.size * 2;
          this.rot = this.rot + 0.1;
          ctx.translate(x, y);
          ctx.rotate(this.rot);
          ctx.beginPath();
          ctx.rect(-this.width / 2, -this.width / 2, this.width, this.width);
          this.draw_shadow(ctx);
          ctx.fillStyle = this.color_to_rgba(this.style.fill);
          ctx.fill();
          ctx.closePath();
          return ctx.restore();
        };

        Square.prototype.isHit = function(x, y) {
          this.layer.ctx.beginPath();
          this.layer.ctx.rect(this.pos.x - this.width / 2, this.pos.y - this.width / 2, this.width, this.width);
          this.layer.ctx.closePath();
          return this.layer.ctx.isPointInPath(x, y);
        };

        return Square;

      })(Shape),
      Ball: Ball = (function(_super) {

        __extends(Ball, _super);

        function Ball() {
          Ball.__super__.constructor.apply(this, arguments);
        }

        Ball.prototype.area = function() {
          return Math.PI * (this.naub.size / 2) * (this.naub.size / 2);
        };

        Ball.prototype.render = function(ctx, x, y) {
          var gradient, offset, size;
          if (x == null) x = 42;
          if (y == null) y = x;
          ctx.save();
          size = this.naub.size;
          offset = 0;
          ctx.translate(x, y);
          ctx.beginPath();
          ctx.arc(offset, offset, size, 0, Math.PI * 2, false);
          ctx.closePath();
          if (this.naub.focused) {
            gradient = ctx.createRadialGradient(offset, offset, size / 3, offset, offset, size);
            gradient.addColorStop(0, this.color_to_rgba(this.style.fill, 80));
            gradient.addColorStop(1, this.color_to_rgba(this.style.fill, 50));
            ctx.fillStyle = gradient;
          } else {
            ctx.fillStyle = this.color_to_rgba(this.style.fill);
          }
          this.draw_shadow(ctx);
          ctx.fill();
          ctx.closePath();
          return ctx.restore();
        };

        return Ball;

      })(Shape),
      Clock: Clock = (function(_super) {

        __extends(Clock, _super);

        function Clock() {
          Clock.__super__.constructor.call(this);
          this.start = 0;
        }

        Clock.prototype.setup = function(naub) {
          this.naub = naub;
          Clock.__super__.setup.call(this, this.naub);
          return this.naub.clock_progress = 0;
        };

        Clock.prototype.render = function(ctx, x, y) {
          var end, offset, size;
          if (x == null) x = 42;
          if (y == null) y = x;
          ctx.save();
          size = this.naub.size - 5;
          end = this.naub.clock_progress * Math.PI / 100;
          offset = 0;
          ctx.translate(x, y);
          ctx.beginPath();
          ctx.arc(offset, offset, size, this.start, end, false);
          ctx.fillStyle = this.color_to_rgba([255, 255, 255, 0.5]);
          ctx.strokeStyle = ctx.fillStyle;
          ctx.lineWidth = size + 3;
          ctx.stroke();
          ctx.closePath();
          return ctx.restore();
        };

        return Clock;

      })(Shape),
      Frame: Frame = (function(_super) {

        __extends(Frame, _super);

        function Frame(margin) {
          this.margin = margin != null ? margin : null;
          Frame.__super__.constructor.call(this);
        }

        Frame.prototype.setup = function(naub) {
          this.naub = naub;
          Frame.__super__.setup.call(this, this.naub);
          if (this.margin != null) {
            return this.frame = this.margin + this.naub.size;
          } else {
            return this.frame = this.naub.frame + this.naub.size * 2;
          }
        };

        Frame.prototype.render = function(ctx, x, y) {
          if (x == null) x = 42;
          if (y == null) y = x;
          x = x - this.frame / 2;
          y = y - this.frame / 2;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, this.frame + y);
          ctx.lineTo(this.frame + x, this.frame + y);
          ctx.lineTo(this.frame + x, y);
          ctx.lineTo(x, y);
          ctx.stroke();
          ctx.closePath();
          return ctx.restore();
        };

        return Frame;

      })(Shape),
      FrameCircle: FrameCircle = (function(_super) {

        __extends(FrameCircle, _super);

        function FrameCircle() {
          FrameCircle.__super__.constructor.apply(this, arguments);
        }

        FrameCircle.prototype.render = function(ctx, x, y) {
          var fill, r;
          if (x == null) x = 42;
          if (y == null) y = x;
          ctx.save();
          ctx.beginPath();
          r = this.naub.physics.margin * this.naub.size;
          ctx.arc(x, y, r, 0, Math.PI * 2, false);
          ctx.closePath();
          ctx.strokeStyle = "black";
          fill = this.style.fill;
          fill[3] = 0.3;
          ctx.fillStyle = this.color_to_rgba(fill);
          ctx.stroke();
          ctx.fill();
          ctx.closePath();
          return ctx.restore();
        };

        return FrameCircle;

      })(Frame),
      PlayButton: PlayButton = (function(_super) {

        __extends(PlayButton, _super);

        function PlayButton() {
          PlayButton.__super__.constructor.apply(this, arguments);
        }

        PlayButton.prototype.render = function(ctx, x, y) {
          ctx.save();
          ctx.beginPath();
          ctx.fillStyle = "#ffffff";
          ctx.moveTo(x - 5, y - 5);
          ctx.lineTo(x - 5, y + 5);
          ctx.lineTo(x + 7, y + 0);
          ctx.lineTo(x - 5, y - 5);
          ctx.closePath();
          ctx.fill();
          return ctx.restore();
        };

        return PlayButton;

      })(Shape),
      PauseButton: PauseButton = (function(_super) {

        __extends(PauseButton, _super);

        function PauseButton() {
          PauseButton.__super__.constructor.apply(this, arguments);
        }

        PauseButton.prototype.render = function(ctx, x, y) {
          ctx.save();
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.rect(x - 5, y - 6, 4, 12);
          ctx.rect(x + 1, y - 6, 4, 12);
          ctx.closePath();
          ctx.fill();
          return ctx.restore();
        };

        return PauseButton;

      })(Shape),
      MainButton: MainButton = (function(_super) {

        __extends(MainButton, _super);

        function MainButton() {
          MainButton.__super__.constructor.apply(this, arguments);
        }

        MainButton.prototype.render = function(ctx, x, y) {
          var text, _ref;
          text = (_ref = Naubino.game.points) != null ? _ref : "";
          this.width = this.naub.size * 2.5;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(Math.PI / 6);
          ctx.beginPath();
          ctx.rect(-this.width / 2, -this.width / 2, this.width, this.width);
          this.draw_shadow(ctx);
          ctx.fillStyle = this.color_to_rgba(this.style.fill);
          ctx.fill();
          ctx.closePath();
          ctx.restore();
          ctx.save();
          ctx.translate(x, y);
          ctx.fillStyle = 'white';
          ctx.textAlign = 'center';
          ctx.font = 'bold 33px Helvetica';
          ctx.fillText(text, 0, 10, this.width * 1.1);
          return ctx.restore();
        };

        return MainButton;

      })(Square),
      StringShape: StringShape = (function(_super) {

        __extends(StringShape, _super);

        function StringShape(string, color) {
          this.string = string;
          this.color = color != null ? color : "black";
          StringShape.__super__.constructor.call(this);
        }

        StringShape.prototype.setup = function(naub) {
          this.naub = naub;
          return StringShape.__super__.setup.call(this, this.naub);
        };

        StringShape.prototype.render = function(ctx, x, y) {
          var size;
          size = this.naub.size * 1.3;
          ctx.save();
          ctx.translate(x, y);
          ctx.fillStyle = this.color;
          ctx.textAlign = 'center';
          ctx.font = "" + size + "px Helvetica";
          ctx.fillText(this.string, 0, 6);
          return ctx.restore();
        };

        return StringShape;

      })(Shape),
      NumberShape: NumberShape = (function(_super) {

        __extends(NumberShape, _super);

        function NumberShape() {
          NumberShape.__super__.constructor.call(this, "", "white");
        }

        NumberShape.prototype.setup = function(naub) {
          this.naub = naub;
          NumberShape.__super__.setup.call(this, this.naub);
          return this.string = this.naub.number;
        };

        return NumberShape;

      })(StringShape)
    };
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define('Game',["Layer", "Naub", "Graph", "Shapes"], function(Layer, Naub, Graph, _arg) {
    var Ball, Clock, Frame, FrameCircle, Game, NumberShape, PauseButton, PlayButton, Square, StringShape;
    Ball = _arg.Ball, Square = _arg.Square, Frame = _arg.Frame, FrameCircle = _arg.FrameCircle, Clock = _arg.Clock, NumberShape = _arg.NumberShape, StringShape = _arg.StringShape, PlayButton = _arg.PlayButton, PauseButton = _arg.PauseButton;
    return Game = (function(_super) {

      __extends(Game, _super);

      function Game(canvas) {
        this.create_naub_triple = __bind(this.create_naub_triple, this);
        this.create_naub_pair = __bind(this.create_naub_pair, this);        Game.__super__.constructor.call(this, canvas);
        this.name = "game";
        this.graph = new Graph(this);
        this.animation.name = "game.animation";
        this.drawing = true;
        this.focused_naub = null;
        this.gravity = Naubino.settings.physics.gravity.game;
        this.joining_allowed = true;
        console.log("mousemove");
        Naubino.mousemove.add(this.move_pointer);
        Naubino.mousedown.add(this.click);
        Naubino.mouseup.add(this.unfocus);
        this.naub_replaced = new Naubino.Signal();
        this.naub_joined = new Naubino.Signal();
        this.naub_destroyed = new Naubino.Signal();
        this.cycle_found = new Naubino.Signal();
        this.naub_focused = new Naubino.Signal();
        this.naub_unfocused = new Naubino.Signal();
        StateMachine.create({
          target: this,
          events: Naubino.settings.events
        });
      }

      Game.prototype.onplaying = function() {
        this.animation.play();
        return this.start_stepper();
      };

      Game.prototype.onleaveplaying = function(e, f, t) {
        return this.stop_stepper();
      };

      Game.prototype.onpaused = function(e, f, t) {
        return this.animation.pause();
      };

      Game.prototype.onstopped = function(e, f, t) {};

      Game.prototype.create_some_naubs = function(n) {
        var _i, _results;
        if (n == null) n = 1;
        _results = [];
        for (_i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--) {
          this.create_naub_pair();
          _results.push(this.create_naub_triple());
        }
        return _results;
      };

      Game.prototype.create_matching_naubs = function(n, extras) {
        var a, b, colors, i, x, y, _i, _j, _ref, _ref2, _ref3, _results;
        if (n == null) n = 1;
        if (extras == null) extras = 0;
        for (_i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--) {
          colors = Util.shuffle([0, 1, 2, 3, 4, 5]);
          colors[5] = colors[0];
          i = 0;
          while (i < colors.length - 1) {
            _ref = this.random_outside(), x = _ref.x, y = _ref.y;
            _ref2 = this.create_naub_pair(x, y, colors[i], colors[i + 1]), a = _ref2[0], b = _ref2[1];
            i++;
          }
        }
        if (extras > 0) {
          _results = [];
          for (_j = 1; 1 <= extras ? _j <= extras : _j >= extras; 1 <= extras ? _j++ : _j--) {
            _ref3 = this.random_outside(), x = _ref3.x, y = _ref3.y;
            _results.push(this.create_naub_pair(x, y));
          }
          return _results;
        }
      };

      Game.prototype.create_naub_pair = function(x, y, color_a, color_b) {
        var dir, naub_a, naub_b, _ref;
        if (x == null) x = null;
        if (y == null) y = x;
        if (color_a == null) color_a = null;
        if (color_b == null) color_b = null;
        if (x == null) _ref = this.random_outside(), x = _ref.x, y = _ref.y;
        naub_a = new Naub(this, color_a);
        naub_b = new Naub(this, color_b);
        color_a = naub_a.color_id;
        color_b = naub_b.color_id;
        naub_a.add_shape(new Ball);
        naub_b.add_shape(new Ball);
        color_a = naub_a.color_id;
        color_b = naub_b.color_id;
        this.add_object(naub_a);
        this.add_object(naub_b);
        naub_a.update();
        naub_b.update();
        dir = Math.random() * Math.PI;
        naub_a.physics.pos.Set(x, y);
        naub_b.physics.pos.Set(x, y);
        naub_a.physics.pos.AddPolar(dir, 15);
        naub_b.physics.pos.AddPolar(dir, -15);
        naub_a.join_with(naub_b);
        return [color_a, color_b];
      };

      Game.prototype.create_naub_triple = function(x, y, color_a, color_b, color_c) {
        var dir, naub_a, naub_b, naub_c, _ref;
        if (x == null) x = null;
        if (y == null) y = x;
        if (color_a == null) color_a = null;
        if (color_b == null) color_b = null;
        if (color_c == null) color_c = null;
        if (x == null) _ref = this.random_outside(), x = _ref.x, y = _ref.y;
        naub_a = new Naub(this, color_a);
        naub_b = new Naub(this, color_b);
        naub_c = new Naub(this, color_c);
        naub_a.add_shape(new Ball);
        naub_b.add_shape(new Ball);
        naub_c.add_shape(new Ball);
        this.add_object(naub_a);
        this.add_object(naub_b);
        this.add_object(naub_c);
        naub_a.update();
        naub_b.update();
        naub_c.update();
        dir = Math.random() * Math.PI;
        naub_a.physics.pos.Set(x, y);
        naub_b.physics.pos.Set(x, y);
        naub_c.physics.pos.Set(x, y);
        naub_a.physics.pos.AddPolar(dir, 30);
        naub_c.physics.pos.AddPolar(dir, -30);
        naub_a.join_with(naub_b);
        return naub_b.join_with(naub_c);
      };

      Game.prototype.random_outside = function() {
        var offset, seed, x, y;
        offset = 100;
        seed = Math.round((Math.random() * 3) + 1);
        switch (seed) {
          case 1:
            x = this.width + offset;
            y = this.height * Math.random();
            break;
          case 2:
            x = this.width * Math.random();
            y = this.height + offset;
            break;
          case 3:
            x = 0 - offset;
            y = this.height * Math.random();
            break;
          case 4:
            x = this.width * Math.random();
            y = 0 - offset;
        }
        return {
          x: x,
          y: y
        };
      };

      Game.prototype.count_basket = function() {
        var count, diff, id, naub, _ref;
        count = [];
        if (this.basket_size != null) {
          _ref = this.objects;
          for (id in _ref) {
            naub = _ref[id];
            diff = this.center.Copy();
            diff.Subtract(naub.physics.pos);
            if (diff.Length() < this.basket_size - naub.size / 2) count.push(naub);
          }
        }
        return count;
      };

      Game.prototype.capacity = function() {
        var filling, naub, r, size, _i, _len, _ref;
        r = this.basket_size;
        size = Math.ceil(r * r * Math.PI * 0.75);
        filling = 0;
        _ref = this.count_basket();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          naub = _ref[_i];
          filling += naub.area();
        }
        return 100 - Math.ceil(filling * 100 / size);
      };

      Game.prototype.destroy_naubs = function(list) {
        var i, naub, one_after_another, _i, _len,
          _this = this;
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          naub = list[_i];
          this.get_object(naub).disable();
        }
        i = 0;
        one_after_another = function() {
          if (i < list.length) {
            _this.get_object(list[i]).destroy();
            i++;
          }
          return setTimeout(one_after_another, 40);
        };
        return one_after_another();
      };

      Game.prototype.check_joining = function(naub, other) {
        var alone, close_related, id, joined, naub_partners, other_alone, other_partners, partner, same_color;
        if (naub.number === other.number || !this.joining_allowed) return false;
        naub_partners = (function() {
          var _ref, _results;
          _ref = naub.joins;
          _results = [];
          for (id in _ref) {
            partner = _ref[id];
            _results.push(partner.number);
          }
          return _results;
        })();
        other_partners = (function() {
          var _ref, _results;
          _ref = other.joins;
          _results = [];
          for (id in _ref) {
            partner = _ref[id];
            _results.push(partner.number);
          }
          return _results;
        })();
        close_related = naub_partners.some(function(x) {
          return __indexOf.call(other_partners, x) >= 0;
        });
        joined = naub.is_joined_with(other);
        alone = Object.keys(naub.joins).length === 0;
        other_alone = Object.keys(other.joins).length === 0;
        same_color = naub.color_id === other.color_id;
        if (!naub.disabled && !joined && same_color && !close_related && !alone && !other_alone) {
          other.replace_with(naub);
          return true;
        } else if (alone && !(other.disabled || naub.disabled)) {
          naub.join_with(other);
          return true;
        }
        return false;
      };

      Game.prototype.draw = function() {
        var id, obj, _ref, _ref2;
        this.ctx.clearRect(0, 0, Naubino.settings.canvas.width, Naubino.settings.canvas.height);
        this.ctx.save();
        _ref = this.objects;
        for (id in _ref) {
          obj = _ref[id];
          obj.draw_joins(this.ctx);
        }
        _ref2 = this.objects;
        for (id in _ref2) {
          obj = _ref2[id];
          obj.draw(this.ctx);
        }
        return this.ctx.restore();
      };

      Game.prototype.clear_objects = function() {
        Game.__super__.clear_objects.call(this);
        return this.graph.clear();
      };

      Game.prototype.step = function(dt) {
        var id, obj, other, _ref, _ref2;
        this.naub_forces(dt);
        if (this.mousedown && this.focused_naub) {
          this.focused_naub.physics.follow(this.pointer.Copy());
          _ref = this.objects;
          for (id in _ref) {
            other = _ref[id];
            if ((this.focused_naub.distance_to(other)) < (this.focused_naub.size + Naubino.settings.naub.fondness)) {
              this.check_joining(this.focused_naub, other);
              break;
            }
          }
        }
        _ref2 = this.objects;
        for (id in _ref2) {
          obj = _ref2[id];
          if (obj.removed) {
            this.remove_obj(id);
            return 42;
          }
        }
      };

      Game.prototype.naub_forces = function(dt) {
        var id, naub, other, _i, _ref, _ref2, _ref3, _results;
        _ref = this.objects;
        _results = [];
        for (id in _ref) {
          naub = _ref[id];
          naub.physics.gravitate(dt);
          _ref2 = naub.joins;
          for (id in _ref2) {
            other = _ref2[id];
            naub.physics.join_springs(other);
          }
          for (_i = 0; _i <= 3; _i++) {
            _ref3 = this.objects;
            for (id in _ref3) {
              other = _ref3[id];
              naub.physics.collide(other);
            }
          }
          _results.push(naub.step(dt));
        }
        return _results;
      };

      return Game;

    })(Layer);
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty;

  define('Keybindings',[],function() {
    var KeyBindings;
    return KeyBindings = (function() {

      function KeyBindings() {
        this.keyup = __bind(this.keyup, this);
        this.keydown = __bind(this.keydown, this);
        this.step = __bind(this.step, this);
        this.disable = __bind(this.disable, this);
        this.enable = __bind(this.enable, this);        this.bindings = {};
        this.active_bindings = {};
      }

      KeyBindings.prototype.enable = function(key, down, up, during) {
        return this.bindings[key] = {
          down: down,
          up: up,
          during: during
        };
      };

      KeyBindings.prototype.disable = function(key) {
        var active_binding, _ref;
        active_binding = this.active_bindings[key];
        if ((_ref = this.bindings[key]) != null) {
          if (typeof _ref.up === "function") _ref.up();
        }
        delete this.bindings[key];
        return delete this.active_bindings[key];
      };

      KeyBindings.prototype.step = function(dt) {
        var during, i, _base, _ref, _results;
        _ref = this.active_bindings;
        _results = [];
        for (i in _ref) {
          if (!__hasProp.call(_ref, i)) continue;
          during = typeof (_base = this.active_bindings[i]).during === "function" ? _base.during(dt) : void 0;
          _results.push(this.active_bindings[i].called = true);
        }
        return _results;
      };

      KeyBindings.prototype.keydown = function(key) {
        var k, _base;
        k = key.which;
        if (k in this.bindings && !(k in this.active_bindings)) {
          if (typeof (_base = this.bindings[k]).down === "function") _base.down();
          return this.active_bindings[k] = {
            during: this.bindings[k].during,
            called: false
          };
        }
      };

      KeyBindings.prototype.keyup = function(key) {
        var called, during, k, _base, _ref;
        k = key.which;
        if (k in this.active_bindings) {
          _ref = this.active_bindings[k], during = _ref.during, called = _ref.called;
          if (!called) if (typeof during === "function") during();
          delete this.active_bindings[k];
          return typeof (_base = this.bindings[k]).up === "function" ? _base.up() : void 0;
        }
      };

      return KeyBindings;

    })();
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('Overlay',["Layer"], function(Layer) {
    var Overlay;
    return Overlay = (function(_super) {

      __extends(Overlay, _super);

      function Overlay(canvas) {
        this.queue_messages = __bind(this.queue_messages, this);        Overlay.__super__.constructor.call(this, canvas);
        this.name = "overlay";
        this.animation.name = "overlay.animation";
        this.fps = 1000 / 15;
        this.drawing = true;
        this.fade_speed = 40;
      }

      Overlay.prototype.draw = function() {
        var buffer, id, _ref;
        this.ctx.clearRect(0, 0, Naubino.game_canvas.width, Naubino.game_canvas.height);
        this.ctx.save();
        _ref = this.objects;
        for (id in _ref) {
          buffer = _ref[id];
          if (buffer.alpha != null) this.ctx.globalAlpha = buffer.alpha;
          this.ctx.drawImage(buffer, 0, 0);
          this.ctx.globalAlpha = 1;
        }
        return this.ctx.restore();
      };

      Overlay.prototype.warning = function(text, font_size, x, y) {
        var color;
        if (font_size == null) font_size = 25;
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        color = this.color_to_rgba(Naubino.colors[0]);
        return this.message(text, font_size, color, x, y);
      };

      Overlay.prototype.fade_in_warning = function(text, callback, font_size, x, y) {
        var color;
        if (callback == null) callback = null;
        if (font_size == null) font_size = 25;
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        color = this.color_to_rgba(Naubino.colors[0]);
        return this.fade_in_message(text, callback, font_size, color, x, y);
      };

      Overlay.prototype.fade_in_message = function(text, callback, font_size, color, x, y, ctx) {
        var fade, mes, mes_id,
          _this = this;
        if (callback == null) callback = null;
        if (font_size == null) font_size = 15;
        if (color == null) color = 'black';
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        if (ctx == null) ctx = this.ctx;
        mes_id = this.message(text, font_size, color, x, y, ctx);
        mes = this.get_object(mes_id);
        mes.alpha = 0.01;
        fade = function() {
          if ((mes.alpha *= 1.2) >= 1) {
            clearInterval(mes.fadeloop);
            mes.alpha = 1;
            if (callback != null) callback.call();
            return console.log('fade in:', text);
          }
        };
        clearInterval(mes.fadeloop);
        mes.fadeloop = setInterval(fade, this.fade_speed);
        return mes_id;
      };

      /* fading out a specific message by id
      */

      Overlay.prototype.fade_out_message = function(mes_id, callback) {
        var fade, mes,
          _this = this;
        if (callback == null) callback = null;
        mes = this.get_object(mes_id);
        fade = function() {
          if ((mes.alpha *= 0.8) <= 0.05) {
            clearInterval(mes.fadeloop);
            if (callback != null) callback.call();
            return _this.remove_obj(mes_id);
          }
        };
        clearInterval(mes.fadeloop);
        if (mes != null) return mes.fadeloop = setInterval(fade, this.fade_speed);
      };

      /* fading out all messages
      */

      Overlay.prototype.fade_out_messages = function(callback) {
        var id, message, _ref;
        if (callback == null) callback = null;
        _ref = this.objects;
        for (id in _ref) {
          message = _ref[id];
          this.fade_out_message(id);
        }
        if (callback != null) return callback();
      };

      Overlay.prototype.fade_in_and_out_message = function(text, callback, font_size, color, x, y, ctx) {
        var fade_out, mes, mes_id, time, _ref, _ref2, _ref3,
          _this = this;
        if (callback == null) callback = null;
        if (font_size == null) font_size = 15;
        if (color == null) color = 'black';
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        if (ctx == null) ctx = this.ctx;
        if (Array.isArray(text)) {
          font_size = (_ref = text[2]) != null ? _ref : font_size;
          time = (_ref2 = text[1]) != null ? _ref2 : 1000;
          text = (_ref3 = text[0]) != null ? _ref3 : "";
        } else {
          time = 2000;
        }
        fade_out = function() {
          return setTimeout(function() {
            return _this.fade_out_message(mes_id, callback);
          }, time);
        };
        mes_id = this.fade_in_message(text, fade_out, font_size, color, x, y, ctx);
        return mes = this.get_object(mes_id);
      };

      Overlay.prototype.queue_messages = function(messages, callback, font_size) {
        var m,
          _this = this;
        if (messages == null) messages = ["hello", "world"];
        if (callback == null) callback = null;
        if (font_size == null) font_size = 15;
        if (m = messages.shift()) {
          messages = messages.slice(0);
          return this.fade_in_and_out_message(m, (function() {
            return _this.queue_messages(messages, callback, font_size);
          }), font_size);
        } else {
          if (callback != null) return callback();
        }
      };

      Overlay.prototype.message = function(text, font_size, color, x, y, ctx) {
        var buffer, line, lines, _i, _len;
        if (font_size == null) font_size = 15;
        if (color == null) color = 'black';
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        if (ctx == null) ctx = this.ctx;
        buffer = document.createElement('canvas');
        buffer.width = Naubino.settings.canvas.width;
        buffer.height = Naubino.settings.canvas.height;
        buffer.alpha = 1;
        ctx = buffer.getContext('2d');
        lines = text.split("\n");
        y -= font_size * lines.length / 2;
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          this.render_text(line, font_size, color, x, y, ctx);
          y += font_size;
        }
        return this.add_object(buffer);
      };

      Overlay.prototype.render_text = function(text, font_size, color, x, y, ctx) {
        if (font_size == null) font_size = 15;
        if (color == null) color = 'black';
        if (x == null) x = this.center.x;
        if (y == null) y = this.center.y;
        if (ctx == null) ctx = this.ctx;
        ctx.fillStyle = color;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 3;
        ctx.strokeStyle = color;
        ctx.textAlign = 'center';
        ctx.font = "" + font_size + "px Helvetica";
        return ctx.fillText(text, x, y);
      };

      return Overlay;

    })(Layer);
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('StandardGame',["Game"], function(Game) {
    var StandardGame;
    return StandardGame = (function(_super) {

      __extends(StandardGame, _super);

      function StandardGame(canvas) {
        this.event = __bind(this.event, this);
        this.check = __bind(this.check, this);        StandardGame.__super__.constructor.call(this, canvas);
      }

      /* state machine
      */

      StandardGame.prototype.oninit = function() {
        var _this = this;
        this.inner_clock = 0;
        this.points = 0;
        Naubino.background.basket_size = this.basket_size;
        this.naub_replaced.add(function(number) {
          return _this.graph.cycle_test(number);
        });
        this.naub_destroyed.add(function() {
          return _this.points++;
        });
        this.cycle_found.add(function(list) {
          return _this.destroy_naubs(list);
        });
        this.basket_size = this.default_basket_size = 160;
        this.spammers = this.default_spammers = {
          pair: {
            method: function() {
              return _this.create_naub_pair(null, null, _this.max_color(), _this.max_color());
            },
            probability: 5
          },
          triple: {
            method: function() {
              return _this.create_naub_triple(null, null, _this.max_color(), _this.max_color(), _this.max_color());
            },
            probability: 0
          }
        };
        this.levels = {
          game: this
        };
        return StateMachine.create({
          target: this.levels,
          initial: 'level1',
          error: function(e, f, t, a, ec, em) {
            if (e !== 'click') return console.warn(e, f, t, a, ec, em);
          },
          events: [
            {
              name: 'reset',
              from: '*',
              to: 'level1'
            }, {
              name: 'levelUp',
              from: 'level1',
              to: 'level2'
            }, {
              name: 'levelUp',
              from: 'level2',
              to: 'level3'
            }, {
              name: 'levelUp',
              from: 'level3',
              to: 'level4'
            }, {
              name: 'levelUp',
              from: 'level4',
              to: 'level5'
            }, {
              name: 'levelUp',
              from: 'level5',
              to: 'level6'
            }, {
              name: 'levelUp',
              from: 'level6',
              to: 'level7'
            }, {
              name: 'levelUp',
              from: 'level7',
              to: 'level8'
            }, {
              name: 'levelUp',
              from: 'level8',
              to: 'level9'
            }
          ],
          callbacks: {
            onchangestate: function() {
              if (this.current !== "level1") {
                Naubino.overlay.animation.play();
                return Naubino.overlay.fade_in_and_out_message(this.current, (function() {
                  return Naubino.overlay.animation.stop();
                }), 35);
              }
            },
            onlevel1: function() {
              console.log(this.current);
              this.game.spammers = this.game.default_spammers;
              this.game.basket_size = this.game.default_basket_size;
              this.game.number_of_colors = 3;
              this.game.spammer_interval = 40;
              return this.game.level_up_limit = 20;
            },
            onlevel2: function() {
              this.game.number_of_colors = 4;
              this.game.spammer_interval = 35;
              return this.game.level_up_limit = 45;
            },
            onlevel3: function() {
              this.game.number_of_colors = 5;
              this.game.spammer_interval = 30;
              return this.game.level_up_limit = 65;
            },
            onlevel4: function() {
              this.game.number_of_colors = 6;
              this.game.spammer_interval = 25;
              return this.game.level_up_limit = 90;
            },
            onlevel5: function() {
              this.game.spammers.triple.probability = 1;
              return this.game.level_up_limit = 120;
            },
            onlevel6: function() {
              this.game.number_of_colors = Naubino.colors.length;
              return this.game.level_up_limit = 140;
            },
            onlevel7: function() {
              this.game.spammer_interval = 20;
              return this.game.level_up_limit = 165;
            },
            onlevel8: function() {
              this.game.spammers.triple.probability = 2;
              this.game.basket_size = 140;
              return this.game.level_up_limit = 200;
            },
            onlevel9: function() {
              Naubino.overlay.animation.play();
              Naubino.overlay.fade_in_and_out_message("you got further than we implemented", Naubino.stop(true));
              return this.game.level_up_limit = 250;
            }
          }
        });
      };

      StandardGame.prototype.max_color = function() {
        return Math.floor(Math.random() * this.number_of_colors);
      };

      StandardGame.prototype.map_spammers = function() {
        var name, spammer, sum, _ref, _results;
        sum = 0;
        _ref = this.spammers;
        _results = [];
        for (name in _ref) {
          spammer = _ref[name];
          sum += spammer.probability;
          _results.push({
            range: sum,
            name: name,
            method: spammer.method
          });
        }
        return _results;
      };

      StandardGame.prototype.spam = function() {
        var dart, max, min, name, probabilites, spam, spammer, _i, _len, _ref;
        probabilites = (function() {
          var _ref, _results;
          _ref = this.spammers;
          _results = [];
          for (name in _ref) {
            spam = _ref[name];
            _results.push(spam.probability);
          }
          return _results;
        }).call(this);
        max = probabilites.reduce(function(f, s) {
          return f + s;
        });
        min = 0;
        dart = Math.floor(Math.random() * (max - min)) + min;
        _ref = this.map_spammers();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          spammer = _ref[_i];
          if (dart < spammer.range) {
            console.log(spammer.name);
            spammer.method();
            return;
          }
        }
      };

      StandardGame.prototype.onchangestate = function(e, f, t) {};

      StandardGame.prototype.onbeforeplay = function() {};

      StandardGame.prototype.onplaying = function() {
        StandardGame.__super__.onplaying.call(this);
        Naubino.background.animation.play();
        Naubino.background.start_stepper();
        this.spamming = setInterval(this.event, 100);
        return this.checking = setInterval(this.check, 300);
      };

      StandardGame.prototype.onleaveplaying = function() {
        StandardGame.__super__.onleaveplaying.call(this);
        clearInterval(this.spamming);
        return clearInterval(this.checking);
      };

      StandardGame.prototype.onpaused = function() {
        StandardGame.__super__.onpaused.call(this);
        Naubino.background.animation.pause();
        return Naubino.background.stop_stepper();
      };

      StandardGame.prototype.onbeforestop = function(e, f, t) {
        if (Naubino.override) {
          console.log("killed");
          return true;
        } else {
          return confirm("do you realy want to stop the game?");
        }
      };

      StandardGame.prototype.onstopped = function(e, f, t) {
        if (e !== 'init') {
          Naubino.background.animation.stop();
          Naubino.background.stop_stepper();
          this.animation.stop();
          this.levels.reset();
          this.stop_stepper();
          this.clear();
          this.clear_objects();
          this.points = 0;
        } else {
          console.info("game initialized");
        }
        return true;
      };

      StandardGame.prototype.check = function() {
        var capacity, critical_capacity;
        capacity = this.capacity();
        critical_capacity = 35;
        if (this.capacity() < critical_capacity) {
          if (Naubino.background.pulsating === false) {
            Naubino.background.start_pulse();
          }
          Naubino.background.ttl = Math.floor(capacity / 2);
        } else if (Naubino.background.pulsating === true) {
          Naubino.background.stop_pulse();
          Naubino.background.ttl = critical_capacity;
        }
        if (this.capacity() < 0) this.lost();
        if (this.points > this.level_up_limit) return this.levels.levelUp();
      };

      StandardGame.prototype.lost = function() {
        Naubino.pause();
        Naubino.overlay.animation.play();
        Naubino.overlay.warning("Naub Overflow", this.basket_size / 4);
        return console.error("you lost", this.levels.current);
      };

      StandardGame.prototype.event = function() {
        if (this.inner_clock === 0) this.spam();
        return this.inner_clock = (this.inner_clock + 1) % this.spammer_interval;
      };

      return StandardGame;

    })(Game);
  });

}).call(this);

(function() {
  var __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('TestCase',["Naub", "Game", "Shapes", "StandardGame"], function(Naub, Game, _arg, StandardGame) {
    var Ball, FrameCircle, NumberShape, TestCase;
    NumberShape = _arg.NumberShape, Ball = _arg.Ball, FrameCircle = _arg.FrameCircle;
    return TestCase = (function(_super) {

      __extends(TestCase, _super);

      function TestCase() {
        TestCase.__super__.constructor.apply(this, arguments);
      }

      TestCase.prototype.oninit = function() {
        var _this = this;
        this.create_matching_naubs();
        this.gravity = true;
        this.naub_replaced.add(function(number) {
          return _this.graph.cycle_test(number);
        });
        this.cycle_found.add(function(list) {
          return _this.destroy_naubs(list);
        });
        return Naubino.play();
      };

      TestCase.prototype.onplaying = function() {
        var weightless,
          _this = this;
        this.animation.play();
        this.start_stepper();
        Naubino.background.animation.play();
        Naubino.background.start_stepper();
        return weightless = function() {
          return _this.gravity = false;
        };
      };

      TestCase.prototype.event = function() {
        var inner_basket;
        inner_basket = this.count_basket();
        return this.destroy_naubs(inner_basket);
      };

      TestCase.prototype.create_naub_pair = function(x, y, color_a, color_b) {
        var dir, naub_a, naub_b, _ref;
        if (x == null) x = null;
        if (y == null) y = x;
        if (color_a == null) color_a = null;
        if (color_b == null) color_b = null;
        if (x == null) _ref = this.random_outside(), x = _ref.x, y = _ref.y;
        naub_a = new Naub(this, color_a);
        naub_b = new Naub(this, color_b);
        color_a = naub_a.color_id;
        color_b = naub_b.color_id;
        naub_a.add_shape(new Ball);
        naub_a.add_shape(new FrameCircle);
        naub_b.add_shape(new Ball);
        naub_b.add_shape(new FrameCircle);
        color_a = naub_a.color_id;
        color_b = naub_b.color_id;
        this.add_object(naub_a);
        this.add_object(naub_b);
        naub_a.add_shape(new NumberShape);
        naub_b.add_shape(new NumberShape);
        naub_a.update();
        naub_b.update();
        dir = Math.random() * Math.PI;
        naub_a.physics.pos.Set(x, y);
        naub_b.physics.pos.Set(x, y);
        naub_a.physics.pos.AddPolar(dir, 15);
        naub_b.physics.pos.AddPolar(dir, -15);
        naub_a.join_with(naub_b);
        return [color_a, color_b];
      };

      return TestCase;

    })(StandardGame);
  });

}).call(this);

(function() {

  define('Settings',[],function() {
    var Settings;
    return Settings = {
      graphics: {
        fps: 35,
        fps_menu: 20,
        draw_shadows: false,
        updating: true
      },
      naub: {
        size: 14,
        mass: 4,
        mass_menu: 40,
        border: false,
        fondness: 12
      },
      physics: {
        fps: 60,
        calming_const: 0.5,
        gravity: {
          menu: true,
          game: true
        },
        margin: 1.2,
        join_length: 3.0,
        spring_force: 0.6,
        friction: 5.0
      },
      canvas: {
        scale: 1,
        width: 800,
        height: 480
      },
      events: [
        {
          name: 'init',
          from: 'none',
          to: 'stopped'
        }, {
          name: 'play',
          from: 'stopped',
          to: 'playing'
        }, {
          name: 'play',
          from: 'paused',
          to: 'playing'
        }, {
          name: 'pause',
          from: 'playing',
          to: 'paused'
        }, {
          name: 'stop',
          from: 'playing',
          to: 'stopped'
        }, {
          name: 'stop',
          from: 'paused',
          to: 'stopped'
        }
      ],
      layer_events: [
        {
          name: 'play',
          from: '*',
          to: 'playing'
        }, {
          name: 'pause',
          from: 'playing',
          to: 'paused'
        }, {
          name: 'stop',
          from: 'playing',
          to: 'stopped'
        }, {
          name: 'stop',
          from: 'paused',
          to: 'stopped'
        }
      ],
      colors: {
        output: [[229, 53, 23, 1, "red"], [151, 190, 13, 1, "green"], [0, 139, 208, 1, "blue"], [255, 204, 0, 1, "yellow"], [226, 0, 122, 1, "pink"], [100, 31, 128, 1, "purple"], [41, 14, 3, 1, "tell me"]],
        high_contrast: [[255, 0, 0, 1, "hcred"], [0, 224, 0, 1, "hcgreen"], [0, 128, 224, 1, "hcblue"], [255, 255, 0, 1, "hcyellow"], [0, 0, 0, 1, "hcblack"], [128, 0, 128, 1, "hcpurple"]],
        normal_colors: [[255, 0, 0, 1, "red"], [255, 153, 0, 1, "Vitamin C"], [0, 153, 204, 1, "Office Blue"], [0, 204, 0, 1, "Astroturf"], [255, 255, 0, 1, "Yellow"]],
        cuddle_bunny: [[174, 49, 45, 1, "cuddling red"], [75, 136, 95, 1, "cuddling green"], [73, 37, 13, 1, "midnight fudge"], [173, 165, 64, 1, "cuddling yellow"], [202, 202, 182, 1, "ill beige"]],
        '70': [[191, 73, 73, 1], [166, 30, 30, 1], [38, 110, 128, 1], [255, 232, 222, 1], [41, 14, 3, 1, "tell me"]],
        lip: [[125, 97, 83, 1], [147, 208, 189, 1], [82, 195, 193, 1], [246, 153, 167, 1], [198, 190, 99, 1]]
      }
    };
  });

}).call(this);

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('Tutorial',["Game"], function(Game) {
    var Tutorial;
    return Tutorial = (function(_super) {

      __extends(Tutorial, _super);

      Tutorial.name = "Tutorial";

      /*
        # Lesson 1
        #   Naubs can be moved
        #   Naubs can be joined
        # Lesson 2
        #   Cycles dissolve
        # vvvv TODO vvvv
        #   Single Naubs can be attached to any color TODO: modify create_matching_naubs accordingly
        # Lesson 3
        #   Naubs keep being generated
        #   Too many Naubs can kill you
      */

      function Tutorial(canvas, graph) {
        this.toggle_joining = __bind(this.toggle_joining, this);        Tutorial.__super__.constructor.call(this, canvas, graph);
      }

      Tutorial.prototype.configure = function() {
        var _this = this;
        Naubino.overlay.animation.play();
        if (Naubino.background.animation.current !== "stopped") {
          Naubino.background.animation.stop();
        }
        this.font_size = 24;
        Naubino.menu_focus.active = false;
        this.joining_allowed = false;
        return this.lessons = StateMachine.create({
          initial: 'welcome',
          error: function(e, f, t, a, ec, em) {
            if (e !== 'click') return console.warn(e, f, t, a, ec, em);
          },
          events: [
            {
              name: 'click',
              from: 'welcome',
              to: 'lesson_show'
            }, {
              name: 'shown',
              from: 'lesson_show',
              to: 'lesson_move'
            }, {
              name: 'moved',
              from: 'lesson_move',
              to: 'lesson_join'
            }, {
              name: 'joined',
              from: 'lesson_join',
              to: 'lesson_cycle'
            }, {
              name: 'click',
              from: 'lesson_cycle',
              to: 'success'
            }
          ],
          callbacks: {
            onchangestate: function(e, f, t) {
              return console.info("" + f + " --(" + e + ")--> " + t);
            },
            onwelcome: function(e, f, t) {
              Naubino.mousedown.active = false;
              Naubino.mousedown.add(function() {
                return _this.lessons.click();
              });
              Naubino.overlay.fade_in_message("Tutorial", null, _this.font_size);
              setTimeout(function() {
                Naubino.overlay.fade_in_message("\n\nclick to continue", null, 12);
                return Naubino.mousedown.active = true;
              }, 1000);
              return setTimeout(function() {
                return Naubino.overlay.fade_in_and_out_message(["use the menu to restart this tutorial at any time", 5000], null, 12, 'black', Naubino.settings.canvas.width / 2, Naubino.settings.canvas.height - 10);
              }, 3000);
            },
            onleavewelcome: function() {
              var _this = this;
              Naubino.overlay.fade_out_messages(function() {
                return _this.transition();
              });
              return false;
            },
            onclick: function() {},
            onlesson_show: function() {
              var messages, strings;
              setTimeout(function() {
                _this.create_naubs();
                _this.for_each(function(naub) {
                  return naub.disable();
                });
                return console.warn("naubs inserted");
              }, 4300);
              strings = [["Lesson 1", 1300, _this.font_size * 2], ["Naubino is all about Naubs", 1000], ["These are Naubs", 1000], ["They always come in pairs", 1000], ["Try to move them around!", 1000]];
              messages = function() {
                return Naubino.overlay.queue_messages(strings, (function() {
                  return _this.lessons.shown();
                }), _this.font_size);
              };
              return setTimeout(messages, 2000);
            },
            onlesson_move: function() {
              var binding1, binding2;
              _this.for_each(function(naub) {
                return naub.enable();
              });
              binding1 = _this.naub_focused.add(function(naub) {
                return naub.old_pos = naub.physics.pos.Copy();
              });
              binding2 = _this.naub_unfocused.add(function(naub) {
                var dragged_distance, new_pos;
                new_pos = naub.physics.pos.Copy();
                new_pos.Subtract(naub.old_pos);
                dragged_distance = new_pos.Length();
                if (dragged_distance > 180) {
                  binding1.detach();
                  binding2.detach();
                  return _this.lessons.moved();
                }
              });
              return _this.fallback_warning_timer = setTimeout((function() {
                return Naubino.overlay.fade_in_and_out_message(["Just drag one pair across.", 3000], null, _this.font_size);
              }), 10000);
            },
            onleavelesson_move: function() {
              clearTimeout(_this.fallback_warning_timer);
              Naubino.overlay.fade_out_messages(function() {
                return _this.transition();
              });
              return false;
            },
            onlesson_join: function() {
              _this.joining_allowed = false;
              _this.naub_replaced.addOnce(function() {
                Naubino.overlay.queue_messages([["nicely done!", 2000]], function() {
                  return _this.lessons.joined();
                }, _this.font_size);
                return _this.toggle_joining();
              });
              return Naubino.overlay.queue_messages([["very Good", 1000], ["Every Naub has a certain color", 1000], ["You can connect pairs of Naubs...", 1400], ["...by dragging on Naub onto\nanother with the same color", 3000], ["Now try to connect two pairs of naubs!", 3000]], _this.toggle_joining, _this.font_size);
            },
            onlesson_cycle: function(e, f, t) {
              _this.cycle_found.add(function() {
                return Naubino.overlay.queue_messages([["Great", 4000]], null, _this.font_size);
              });
              return Naubino.overlay.queue_messages([["now connect the remaining naubs", 2500], ["and see what happens...", 2000]], _this.toggle_joining, _this.font_size);
            },
            onsuccess: function() {
              return console.info;
            }
          }
        });
      };

      Tutorial.prototype.onplaying = function() {
        Tutorial.__super__.onplaying.call(this);
        return this.configure();
      };

      /* utility
      */

      Tutorial.prototype.toggle_joining = function() {
        this.joining_allowed = !this.joining_allowed;
        return console.log("joining_allowed", this.joining_allowed);
      };

      Tutorial.prototype.create_naubs = function() {
        var weightless;
        this.gravity = true;
        this.create_matching_naubs(1);
        this.start_stepper();
        weightless = function() {
          return this.gravity = false;
        };
        return setTimeout(weightless, 5500);
      };

      return Tutorial;

    })(Game);
  });

}).call(this);

(function() {
  var __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define('Menu',["Menu", "Layer", "Naub", "Graph", "Shapes"], function(Menu, Layer, Naub, Graph, _arg) {
    var Ball, MainButton, PauseButton, PlayButton, StringShape;
    Ball = _arg.Ball, StringShape = _arg.StringShape, PlayButton = _arg.PlayButton, PauseButton = _arg.PauseButton, MainButton = _arg.MainButton;
    return Menu = (function(_super) {

      __extends(Menu, _super);

      function Menu(canvas) {
        Menu.__super__.constructor.call(this, canvas);
        this.name = "menu";
        this.graph = new Graph(this);
        this.animation.name = "menu.animation";
        this.objects = {};
        this.hovering = false;
        this.drawing = true;
        this.gravity = Naubino.settings.physics.gravity.menu;
        this.listener_size = this.default_listener_size = 45;
        Naubino.mousemove.add(this.move_pointer);
        Naubino.mousedown.add(this.click);
        Naubino.menu_button.active = false;
        this.physics_fps = 35;
        this.position = new b2Vec2(20, 25);
        this.cube_size = 45;
        StateMachine.create({
          target: this,
          events: Naubino.settings.events,
          error: function(e, from, to, args, code, msg) {
            return console.error("" + this.name + "." + e + ": " + from + " -> " + to + "\n" + code + "::" + msg);
          }
        });
        /* definition of each button
        TODO: position should be dynamic
        */
      }

      Menu.prototype.oninit = function() {
        this.add_buttons();
        return this.start_stepper();
      };

      Menu.prototype.buttons = {
        main: {
          position: new b2Vec2(20, 25),
          shapes: [new MainButton]
        },
        play: {
          "function": function() {
            return Naubino.play();
          },
          position: new b2Vec2(65, 35),
          shapes: [new Ball, new PlayButton]
        },
        help: {
          "function": function() {
            return Naubino.tutorial();
          },
          position: new b2Vec2(45, 65),
          shapes: [new Ball, new StringShape("?", "white")]
        },
        exit: {
          "function": function() {
            return Naubino.stop();
          },
          position: new b2Vec2(14, 80),
          shapes: [new Ball, new StringShape("X", "white")]
        }
      };

      Menu.prototype.add_buttons = function() {
        var button, name, shape, _i, _len, _ref, _ref2;
        _ref = this.buttons;
        for (name in _ref) {
          button = _ref[name];
          this.objects[name] = new Naub(this);
          _ref2 = button.shapes;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            shape = _ref2[_i];
            this.objects[name].add_shape(shape);
          }
          this.objects[name].update();
          this.objects[name].focus = button["function"];
          this.objects[name].disabled = button.disabled;
          this.objects[name].isClickable = false;
          this.objects[name].physics.pos.Set(button.position.x, button.position.y);
          this.objects[name].physics.mass = Naubino.settings.naub.mass_menu;
          this.objects[name].physics.attracted_to.Set(button.position.x, button.position.y);
          this.graph.remove_join(this.objects[name].join_with(this.objects.main, name));
        }
        return this.objects.main.life_rendering = true;
      };

      Menu.prototype.onenterplaying = function() {
        this.objects.play.focus = function() {
          return Naubino.pause();
        };
        this.objects.play.shapes.pop();
        this.objects.play.add_shape(new PauseButton);
        return this.objects.play.update();
      };

      Menu.prototype.onenterpaused = function() {
        this.objects.play.focus = function() {
          return Naubino.play();
        };
        this.objects.play.shapes.pop();
        this.objects.play.add_shape(new PlayButton);
        return this.objects.play.update();
      };

      Menu.prototype.onenterstopped = function(e, f, t) {
        if (e !== 'init') return this.onenterpaused();
      };

      Menu.prototype.step = function(dt) {
        var name, naub, _ref, _results;
        _ref = this.objects;
        _results = [];
        for (name in _ref) {
          naub = _ref[name];
          naub.step(dt);
          if (this.hovering) {
            _results.push(naub.physics.gravitate(dt));
          } else {
            _results.push(naub.physics.gravitate(dt, this.position));
          }
        }
        return _results;
      };

      Menu.prototype.update = function() {
        return this.objects.main.update();
      };

      Menu.prototype.move_pointer = function(x, y) {
        var _ref;
        return _ref = [x, y], this.pointer.x = _ref[0], this.pointer.y = _ref[1], _ref;
      };

      Menu.prototype.draw = function() {
        this.draw_menu();
        return this.draw_listener_region();
      };

      Menu.prototype.draw_menu = function() {
        var name, naub, _ref;
        this.ctx.clearRect(0, 0, Naubino.game_canvas.width, Naubino.game_canvas.height);
        this.ctx.save();
        _ref = this.objects;
        for (name in _ref) {
          naub = _ref[name];
          if (!naub.disabled) naub.draw_joins(this.ctx);
          if (!naub.disabled) naub.draw(this.ctx);
        }
        this.objects.main.draw(this.ctx);
        this.objects.main.draw_joins();
        this.draw_listener_region();
        return this.ctx.restore();
      };

      Menu.prototype.draw_listener_region = function() {
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.arc(0, 15, this.listener_size, 0, Math.PI * 2, true);
        if (this.ctx.isPointInPath(this.pointer.x, this.pointer.y)) {
          if (!this.hovering) {
            Naubino.menu_focus.dispatch();
            this.for_each(function(b) {
              return b.isClickable = true;
            });
            this.listener_size = 90;
            this.start_stepper();
          }
        } else if (this.hovering) {
          Naubino.menu_blur.dispatch();
          this.for_each(function(b) {
            return b.isClickable = false;
          });
          this.listener_size = this.default_listener_size;
          setTimeout(this.stop_stepper, 1000);
        }
        this.ctx.closePath();
        return this.ctx.restore();
      };

      return Menu;

    })(Layer);
  });

}).call(this);

(function() {

  define('Naubino',["Background", "Game", "Keybindings", "Menu", "Overlay", "StandardGame", "TestCase", "Settings", "Tutorial"], function(Background, Game, KeyBindings, Menu, Overlay, StandardGame, TestCase, Settings, Tutorial) {
    var Naubino;
    return Naubino = (function() {

      function Naubino() {
        console.log("Naubino Constructor");
        this.name = "Naubino";
        this.settings = Settings;
        this.colors = this.settings.colors.output;
        this.create_fsm();
        this.Signal = window.signals.Signal;
        this.add_signals();
        this.add_listeners();
      }

      Naubino.prototype.setup = function() {
        this.init_dom();
        this.init_layers();
        this.setup_keybindings();
        this.setup_cursorbindings();
        return console.timeEnd("loading");
      };

      Naubino.prototype.print = function() {
        return this.gamediv.insertAdjacentHTML("afterend", "<img src=\"" + (this.game_canvas.toDataURL()) + "\"/>");
      };

      Naubino.prototype.init_dom = function() {
        var canvas, _i, _len, _ref, _results;
        this.gamediv = document.querySelector("#gamediv");
        this.overlay_canvas = document.querySelector("#overlay_canvas");
        this.menu_canvas = document.querySelector("#menu_canvas");
        this.game_canvas = document.querySelector("#game_canvas");
        this.background_canvas = document.querySelector("#background_canvas");
        _ref = this.gamediv.querySelectorAll("canvas");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          canvas = _ref[_i];
          canvas.width = this.settings.canvas.width;
          _results.push(canvas.height = this.settings.canvas.height);
        }
        return _results;
      };

      Naubino.prototype.init_layers = function() {
        var width;
        this.gamediv.max - (width = this.settings.canvas.width);
        this.background = new Background(this.background_canvas);
        this.game_standard = new StandardGame(this.game_canvas);
        this.game_testcase = new TestCase(this.game_canvas);
        this.game_tutorial = new Tutorial(this.game_canvas);
        this.game = this.game_standard;
        this.menu = new Menu(this.menu_canvas);
        this.overlay = new Overlay(this.overlay_canvas);
        this.menu.init();
        this.menu.animation.play();
        return this.game.init();
      };

      /*
        Everything has to have state
      */

      Naubino.prototype.create_fsm = function() {
        return StateMachine.create({
          target: this,
          initial: {
            state: 'stopped',
            event: 'init'
          },
          events: this.settings.events,
          error: function(e, from, to, args, code, msg) {
            return console.error("" + this.name + "." + e + ": " + from + " -> " + to + "\n" + code + "::" + msg);
          }
        });
      };

      Naubino.prototype.list_states = function() {
        var o, _i, _len, _ref, _results;
        this.name = "Naubino";
        _ref = [this, this.menu, this.game, this.overlay.animation, this.menu.animation, this.game.animation, this.background.animation];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          o = _ref[_i];
          switch (o.current) {
            case 'playing':
              _results.push(console.info(o.name, o.current));
              break;
            case 'paused':
              _results.push(console.warn(o.name, o.current));
              break;
            case 'stopped':
              _results.push(console.warn(o.name, o.current));
              break;
            default:
              _results.push(console.error(o.name, o.current));
          }
        }
        return _results;
      };

      Naubino.prototype.onchangestate = function(e, f, t) {
        return console.info("Naubino changed states " + e + ": " + f + " -> " + t);
      };

      Naubino.prototype.onbeforeplay = function(event, from, to) {
        return this.game.play();
      };

      Naubino.prototype.onenterplaying = function() {
        return this.menu.play();
      };

      Naubino.prototype.toggle = function() {
        switch (this.current) {
          case 'playing':
            return this.pause();
          case 'paused':
            return this.play();
          case 'stopped':
            return this.play();
        }
      };

      Naubino.prototype.onbeforepause = function(event, from, to) {
        if (from !== "init") {
          this.game.pause();
          return this.menu.pause();
        }
      };

      Naubino.prototype.onenterpaused = function() {};

      Naubino.prototype.onpause = function(event, from, to) {};

      Naubino.prototype.onbeforestop = function(event, from, to, override) {
        this.override = override != null ? override : false;
        this.game.stop();
        if (this.game.current === "stopped") {
          return this.menu.stop();
        } else {
          return false;
        }
      };

      Naubino.prototype.tutorial = function() {
        this.game_tutorial = new Tutorial(this.game_canvas);
        return this.soft_switch(this.game_tutorial);
      };

      Naubino.prototype.soft_switch = function(new_game) {
        var _this = this;
        if (this.current === "playing") this.pause();
        return this.game.fade_out(function() {
          _this.game.clear();
          _this.game = new_game;
          _this.game.draw();
          if (_this.game.current === "none") _this.game.init();
          return _this.game.fade_in(function() {
            return _this.play();
          });
        });
      };

      Naubino.prototype.scale = function(nscale) {
        var canvas, oscale, ratio, _i, _len, _ref, _results;
        console.log(oscale = 1);
        this.settings.canvas.scale = nscale;
        console.log(ratio = nscale / oscale);
        _ref = this.gamediv.querySelectorAll("canvas");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          canvas = _ref[_i];
          _results.push(canvas.getContext('2d').scale(ratio, ratio));
        }
        return _results;
      };

      /*
        Signals connect everything else that does not react to events
      */

      Naubino.prototype.add_signals = function() {
        this.mousedown = new this.Signal();
        this.mouseup = new this.Signal();
        this.mousemove = new this.Signal();
        this.keydown = new this.Signal();
        this.keyup = new this.Signal();
        this.touchstart = new this.Signal();
        this.touchend = new this.Signal();
        this.touchmove = new this.Signal();
        this.menu_button = new this.Signal();
        this.menu_focus = new this.Signal();
        return this.menu_blur = new this.Signal();
      };

      Naubino.prototype.add_listeners = function() {
        var _this = this;
        this.menu_focus.add(function() {
          return _this.menu.hovering = _this.menu_button.active = true;
        });
        return this.menu_blur.add(function() {
          return _this.menu.hovering = _this.menu_button.active = false;
        });
      };

      Naubino.prototype.setup_keybindings = function() {
        var _this = this;
        this.keybindings = new KeyBindings();
        window.onkeydown = function(key) {
          return _this.keybindings.keydown(key);
        };
        window.onkeyup = function(key) {
          return _this.keybindings.keyup(key);
        };
        return this.keybindings.enable(32, function() {
          return _this.toggle();
        });
      };

      Naubino.prototype.setup_cursorbindings = function() {
        var onmousedown, onmousemove, onmouseup,
          _this = this;
        onmousemove = function(e) {
          var x, y;
          x = (e.pageX - _this.overlay_canvas.offsetLeft) / _this.settings.canvas.scale;
          y = (e.pageY - _this.overlay_canvas.offsetTop) / _this.settings.canvas.scale;
          return _this.mousemove.dispatch(x, y);
        };
        onmouseup = function(e) {
          var x, y;
          x = (e.pageX - _this.overlay_canvas.offsetLeft) / _this.settings.canvas.scale;
          y = (e.pageY - _this.overlay_canvas.offsetTop) / _this.settings.canvas.scale;
          return _this.mouseup.dispatch(x, y);
        };
        onmousedown = function(e) {
          var x, y;
          x = (e.pageX - _this.overlay_canvas.offsetLeft) / _this.settings.canvas.scale;
          y = (e.pageY - _this.overlay_canvas.offsetTop) / _this.settings.canvas.scale;
          return _this.mousedown.dispatch(x, y);
        };
        this.overlay_canvas.addEventListener("mousedown", onmousedown, false);
        this.overlay_canvas.addEventListener("mouseup", onmouseup, false);
        this.overlay_canvas.addEventListener("mousemove", onmousemove, false);
        this.overlay_canvas.addEventListener("mouseout", onmouseup, false);
        this.overlay_canvas.addEventListener("touchstart", onmousedown, false);
        this.overlay_canvas.addEventListener("touchend", onmouseup, false);
        return this.overlay_canvas.addEventListener("touchmove", onmousemove, false);
      };

      return Naubino;

    })();
  });

}).call(this);

(function() {

  console.time("loading");

  define('Load',["Naubino"], function(Naubino) {
    console.log(Naubino);
    return window.onload = function() {
      window.Naubino = new Naubino();
      return window.Naubino.setup();
    };
  });

}).call(this);
